\input texinfo @c -*- texinfo -*-

@c ==============================================================
@c NAME:    nodeWithReact.twjr
@c DATE:    2018-01-08T07:53:47
@c VERSION: VERSION 0.3.0
@c DESC:    Udemy Node With React---Fullstack Web Development V4
@c BY:      LOLH
@c NOTES:   
@c ==============================================================

@c %**start of header
@c edit
@setfilename nodeWithReact.info
@c edit
@settitle Node With React
@c %**end of header

@c ====================
@c texiwebjr specials
@c ====================
@c Changes how xref titles are quoted.
@dquotexrefs

@c Lets braces in index entries work.
@allowindexbraces

@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex

@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c ====================
@c DOCUMENT CONSTANTS
@c ====================
@set UPDATE-MONTH JANUARY 2018
@set EDITION 0.3.0
@set AUTHOR LOLH
@set TITLE Notes for Node with React---Fullstack Web Development V4
@set SHORTTITLE Node with React
@set SUBTITLE by Stephen Grider
@set COPYRIGHT_YEAR 2017
@set COPYRIGHT_HOLDER LOLH

@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook

@c ====================
@c FINALOUT
@c ====================
@c If "finalout" is commented out, the printed output will show
@c black boxes that mark lines that are too long.  Thus, it is
@c unwise to comment it out when running a master in case there are
@c overfulls which are deemed okay.

@iftex
@c |@finalout|
@end iftex

@c ====================
@c SUMMARY & COPYRIGHT INFORMATION
@c ====================
@copying
@c insert a short summary describing and identifying this document in a
@c sentence or two, and add the copyright notice and copying permisions

This document is @value{TITLE} @sp 2
This document does @dots{}

Copyright @copyright{} @value{COPYRIGHT_YEAR} LOLH @*
by @value{COPYRIGHT_HOLDER} @*
All Rights Reserved

@quotation
Permission is granted to @dots{}
@end quotation

@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.

@c use @insertcopying later to 'emit' this copying information in a TeX
@c or plain text document; add to the Top node for use in Info or HTML file
@end copying

@c ====================
@c TITLEPAGE, COPYRIGHT PAGE, TOC PAGE, HEADINGS
@c ====================
@titlepage

@title @value{TITLE}
@subtitle @value{SUBTITLE}
@c @subtitle Additional Subtitle
@author @value{AUTHOR}

@c place the copyright information on the backside of the titlepage
@c (printed manual only)
@page
@vskip 0pt plus 1filll
@insertcopying

Published by @dots{}

@end titlepage
@c page numbering and headings start after end of titlepage

@iftex
@headings off
@evenheading @thispage @| @value{DRAFT} @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| @value{DRAFT} @| @thispage
@end iftex

@c TOC in the printed manual
@c consider placing TOC after the main menu
@c consider including summarycontents here or after main menu
@c @summarycontents
@contents

@c ====================
@c TOP NODE, MASTER MENU
@c ====================
@ifnottex
@ifnotdocbook
@ifnotxml
@node Top
@top Node With React

@insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex

@c ====================
@c START OF BODY
@c ====================

@c Preface and Foreward come right after Top node in 'unnumbered' sections
@c consider commenting out Foreward and Preface
@menu

@detailmenu
 --- The Detailed Node Listing ---

@end detailmenu
@end menu

@node Foreword
@unnumbered Foreword

Foreward text...

@node Preface
@unnumbered Preface

Preface text...

@node Overview
@unnumberedsec Overview

Text and chapter by chapter description here.

@node Conventions
@unnumberedsec Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{http://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo

@node Acknowledgements
@unnumberedsec Acknowledgements

Acknowledgments here...

@c ====================
@c MAIN BODY NODES
@c ====================

@node Introduction
@unnumbered Introduction

@<App Header@> =
/*
 * FILE:   index.js
 *         --------
 * VER:    v0.3.0
 * DATE:   2018-01-08T07:54:09
 * AUTHOR: LOLH
 * ABOUT:  Entry-point for app 'emaily';
 *         Initialize and start application services, such as
 *         server and routes, authentication, database
 * NOTES:  From Udemy course 'Node with React---Full Stack
 *         Web Development version 4'
 * TODO:   
 *************************************************************/
@

Build and deploy fullstack web apps with NodeJS, React, Redux, Express, and MongoDB.

Course website: @url{https://www.udemy.com/node-with-react-fullstack-web-development/learn/v4/content}

@node About
@unnumberedsec About This Course

Build and deploy fullstack web apps with NodeJS, React, Redux, Express,
and MongoDB.

195 Lectures

25.5 hours of video

@node Description
@unnumberedsec Course Description

Note: This course assumes you've got the basics of React and Redux down.
Check out my course 'Modern React with Redux', its the perfect
preparation!

Go beyond the basics of React and Redux!  This course will teach you to
combine the ultra-popular React, Redux, Express, and MongoDB
technologies to build a fullstack web application.

Advanced Deployment? You will learn it.  Billing/Payments? Included.
Handling Email? Of course!

@subsubheading What Will You Build?

All of my courses are 'learn-by-doing': no boring endless lectures with
Powerpoints, only live, interactive coding examples.  In this course
we'll build one massive web application that profiles the advanced
features of React, Redux, Express, and Mongo.  By putting each concept
into a real app, you'll get a better idea of when to use each unique and
powerful feature.

Build a large feedback-collection app. This mega app will include the
full gamut of features, including everything from authentication to
email handling.  You'll learn how to build an app that can be used to
send mass emails to a big list of users for the purpose of collecting
feedback.  It's my goal to ensure you understand each feature we build
into this app so you can apply them to your own personal or professional
projects in the future.

@subsubheading Here's what we'll learn

@itemize
@item
Learn the architectural considerations of building a full stack app

@item
Connect a front-end Create-React-App server to a NodeJS and Express
backend

@item
Communicate data from your Mongo database to your React application

@item
Understand how to route user requests on the front end with React Router
and on the backend with Express

@item
Build reusable user inputs with Redux Form, complete with navigation

@item
Handle credit cards and receive payments from your users with Stripe

@item
Engage your users with automated emails

@item
Enhance authentication flows in your app with Google OAuth
authentication

@item
Separate production and development resources with advanced API key
handling techniques

@item
Educate your users on how to use your app with custom build landing
pages

@end itemize

I've built the course that I would have wanted to take when I was
learning to build fullstack apps. A course that explains the concepts
and how they're implemented in the best order for you to learn and
deeply understand them.

@subsubheading What am I going to get from this course?

@itemize
@item
Create boilerplate starter projects with React, Redux, Express, and
Mongo

@item
Understand common web technologies and design patterns to connect them
together

@item
Master deployment techniques between the production and development
environments

@item
Make an app with Google OAuth authentication

@item
Learn to effectively create and send emails from a backend server

Accept and process credit card payments from users
@end itemize

@node Course Overview
@chapter Course Overview
@cindex overview

Course Overview

NodeJS version must be at least version 8.1.1.

@node Help
@section How to Get Help
@cindex help

@enumerate
@item
Udemy Discussion Threads

@item
PM Stephen Grider on Udemy

@item
Twitter @url{https://twitter.com/ste_grider}

@item
Official Course Repo GitHub
@enumerate a
@item
@url{https://github.com/StephenGrider/FullstackReactCode/issues}

@item
Poor notifications; use PM or Tweet as well
@end enumerate

@end enumerate

@node Resources
@section Course Resources Document
@cindex resources document

@subheading Course Resources Documents

@url{https://goo.gl/Xv4ZgB}

@subheading Course Diagrams

Can view all course diagrams at GitHub site:

@url{https://github.com/StephenGrider/FullstackReactCode/tree/master/diagrams}

All diagrams are authored by @url{https:www.draw.io/, Draw IO}

@subsubheading How to edit diagrams on own:

@itemize
@item
Go to above GitHub site

@item
open folder containing set of diagrams you want to edit

@item
click on @file{.xml} file

@item
click on @samp{raw} button

@item
copy the URL

@item
go to @url{https://www.draw.io}

@item
on the @samp{Save Diagrams To...} window click @key{Decide later} at the
bottom

@item
click @key{File} @result{} @samp{Import From} @result{} @samp{URL}

@item
paste the link to the XML file
@end itemize


@node Prettier
@section Prettier Setup
@cindex prettier

Optional editor add-on to auto-format your JS code.

@url{https://github.com/prettier/prettier}

@subheading Prettier-js for Emacs

@url{https://github.com/prettier/prettier-emacs}

@file{prettier-js} is a function that formats the current buffer using
@file{prettier}. The package also exports a minor mode that applies
@code{(prettier-js}) on save.

Go to the above web page to review @slanted{configuration}.

@node App Overview
@section App Overview
@cindex overview, app

@heading Feedback Collection Application

marketed to startup owners and product managers.

@subheading Hypothetical Situation

@itemize
@item
Someone uses startup owner's app/service

@item
Startup owner wants feedback

@item
Send customer an email requesting feedback

@item
Get tabulation of results

@item
Make app/server better with feedback
@end itemize

It will be quite diverse in its feature set.  It will send out a lot of
emails to different people.  There should be some kind of billing
feature.  There would also need to be user accounts as well, which
requires authentication.

@node App User Flow
@section App User Flow Walkthrough
@cindex app user flow
@cindex user flow, app

Here is a detailed walk-through of how a use will make use of the
application and a discussion of all the different technologies that will
need to be incorporated into the application.

@enumerate
@item
User signs up via Google OAuth

@item
User pays for email credits via stripe

@item
User creates a new 'campaign'

@item
User enters list of emails to send survey to

@item
We send emails to list of surveyees

@item
Surveyees click on link in email to provide feedback

@item
We tabulate feedback

@item
User can see report of all survey responses
@end enumerate

@node Tech Stack
@section Tech Stack
@cindex tech stack
@cindex stack, tech

@enumerate
@item
Authentication:  Express server + MongoDB + PasportJS

@item
Payment: Stripe + MongoDB

@item
Campaign: React + Redux + Redux Form

@item
Emails: Email provider

@item
Feedback: Email provider, Express, Mongo

@item
Tabulate Feedback: Mongo

@item
Report: Mongo + React + Redux
@end enumerate

@node App Mockups
@section App Mockups
@cindex mockups, app
@cindex app mockups

@enumerate
@item
Landing Page; app called @samp{Emaily}; will have a Login button, and
some text; not too concerned about styling; focus on functionality.

@item
Login Button: OAuth flow

@item
Results screen of all different campaigns; name of campaign; list of
responses; other buttons for payment;

@item
Credit card payment

@item
Create a new survey (campaign); add information

@item
Review input information; submit
@end enumerate

@node Server
@chapter Server Side Architecture
@cindex server side architecture
@cindex architecture, server

Discussion about @i{how} to write the code to make the application.

Discussion about the tech stack that will be built and how they will all
communicate with each other.  Primary concern of this course is to
provide direction on getting all of these technologies to work
together.  

@node Application Architecture
@section Application Architecture
@cindex architecture, application
@cindex React app
@cindex Mongo database
@cindex Express server
@cindex API
@cindex AJAX
@cindex JSON

@itemize
@item
Browser at domain sends browseree an HTML document and some files that
contain a React application.

@item
React application does not have the data; the data will be stored on a
Mongo database, i.e., surveys and results of surveys.  The problem to be
solved will be how to get the data in the Mongo database into the React
application.

@item
The React app will never communicate directly with MongoDB; instead,
there will be an Express API in between the React app and the Mongo
database.  The API takes in requests from the app, pulls information out
of the database, and sends it to the app.

@item
React and Express communicate solely through HTTP requests (AJAX
requests); each request contains some JSON.

@itemize
@item
React App

@item
HTTP Request/Response

@item
Express/Node API

@item
MongoDB
@end itemize
@end itemize

Will start with the Express Server first.

@node Node and Express
@section Relationship Between Node and Express
@cindex node and express
@cindex express and node

@set PROJECT server
@set BASE_FILENAME nodeWithReact

Will start a brand new Node project directory and install Express into
it, and then discuss the differences between Node and Express inside the
project.  The new project directory will be @file{@value{PROJECT}}.  The
base filename will be @file{@value{BASE_FILENAME}}.  NPM will create a
new @file{package.json} file in the project directory through the
@code{npm init --yes} command.

@node Install Node Project With Express
@subsection Install a New Node Project With Express
@cindex install node project
@cindex node project, install
@cindex express node project
@cindex package.json, create

@itemize
@item
Create project directory @file{@value{PROJECT}}

@<Makefile Root Definition@>=
ROOT := server

@

@<Makefile Base Filename Definition@>=
FILENAME := nodeWithReact
@

@item
Initialize new Node Project: @code{npm init --yes}

@<Makefile Filename Definitions Hook@>=
PACKAGE.JSON := ${ROOT}/package.json
@

@<Makefile NPM Hooks@>=
.Phony : npm-init
npm-init : ${PACKAGE.JSON}
${PACKAGE.JSON} : | ${ROOT}
	cd ${ROOT} && npm init --yes
@

@<Makefile NPM@>=
NPM = npm-init
@

@item
Install @file{express}

@<Makefile NPM Hooks@>=
 
.Phony : npm-install
npm-install : ${PACKAGE.JSON}
	-[ ! -d ${ROOT}/node_modules ] && cd ${ROOT} && npm install ${NPM_INSTALLS}
@

@<Makefile NPM@>=
NPM = npm-install
@

@<Makefile Filename Definitions Hook@>=
@<Makefile NPM_INSTALLS@>
@

@<Makefile NPM_INSTALLS@>=
NPM_INSTALLS += express
@

@end itemize

@node Relationship Between Node and Express
@subsection Relationship Between Node and Express Inside the App
@cindex node and express, relationship
@cindex express and node, relationship
@cindex relationship between node and express

@table @code
@item Node
Javascript runtime used to execute code outside of the browswer;
traditionally, JavaScript code has always been executed inside a web
browser; that is how JavaScript got its start; people wanted to execute
JavaScript code outside the browswer in some other environments; Node
makes that possible.

@item Express
Library that runs in the Node runtime; has helpers (functions) to make
dealing with HTTP traffic easier;
@end table

@subheading How Node and Express Work Together
@cindex port
@cindex HTTP requests
@cindex HTTP responses
@cindex requests
@cindex reponses
@cindex route handlers
@cindex Route Handler

When a server is running, it is looking for HTTP traffic coming in on a
particular @dfn{port}, a door through which HTTP requests can be
routed.  Node listens for traffic on a particular port and then takes
that information and hands it off to @file{express} for help.  Node
actually handles all of the underlying HTTP traffic.

@file{express} then looks at the @dfn{request} and decides what part of
its code will @dfn{handle} or respond to that request.  The coder will
write a collection of @dfn{route handlers} to handle HTTP requests that
are asking for a very particular service.

@itemize
@item
Route Handler #1

@item
Route Handler #2

@item
Route Handler #3
@end itemize

These route handlers then send a @dfn{response} back to Node, and Node
will respond to the incoming HTTP request.

@node Express Apps
@section Generating Express Apps
@cindex express apps
@cindex index.js

Create the root file @file{index.js} in the root directory of the
project: @value{PROJECT}

@<Makefile Filename Definitions Hook@>=
INDEX.JS := index.js
@

Import @file{express} library, then create an @samp{application} by
executing the @file{express} code.  That is, inside of a single Node.js
project, there might be several different @file{express} applications.
Executing @file{express} as a function returns a running express app
referenced by the @var{app} variable.

@var{app} is used to set up configuration to listen for incoming HTTP
requests that are being routed from Node to @file{express} and will then
route those requests to different route handlers.  The route handlers
will be associated with the @file{express} @var{app} that we create here.

@(index0.js@)=
@<Index0JS Requirements@>
@<Index0JS Constant Definitions@>
@<Create App@>
@<Create Initial Route Handlers@>
@<Start App@>
@

@set VERSION 0.1.0
@set DATETIME 2018-01-07T13:30:47

@<Index0JS Requirements@>=
 
@<App Header@>

/*********************
  REQUIREMENTS
 *********************/
@<Import Express@>
@

@<Create App@>=
 
/*********************
  APPLICATION SERVER
 *********************/
const app = express();
@

This code tells Node that the application wants to receive requests
coming in from port 5000.

@<Start App@>=
 
/*-------------------
 * Start Server
 *-------------------*/
app.listen(PORT);
@

@subheading Create the first Route Handler in @var{app}
@<Create Initial Route Handlers@>=
@<Create Route Handlers@>
@

@<Create Route Handlers@>=
 
/*********************
  ROUTE HANDLERS
 *********************/
@<Root Route Handler@>
@

@<Root Route Handler@>=
app.get('/', (req, res) => {
  res.send({"hi": "there"});
});
@

@node Move Index Hook
@subsection Move Index Hook

@<Makefile Move Hook@>=
@<Makefile Move INDEX.JS Hook@>
@

@<Makefile Move INDEX.JS Hook@>=
.Phony : move-indexjs
move-indexjs : | ${ROOT}
	mv index*.js ${ROOT}
@

@<Makefile Move Prereqs@>=
MOVE_PREREQS += move-indexjs
@

@node Link Index0
@subsection Link Index0
@cindex link index0.js

@<Makefile Link Target Hook@>=
	ln -f ${ROOT}/index0.js ${ROOT}/index.js
@

@node Express
@subsection Express
@cindex express

Will be using @dfn{common js modules} on the server side because at this
time Node only has support for this, and not @dfn{ES2015} modules using
the @code{import @dots{} from <module>} syntax.  The front end (React
side), we can use @samp{ES2015} modules, however.

@<Import Express@>=
const express = require('express');
@

@node Index JS Constants
@subsection @file{index.js} Constant Definitions
@cindex constant definitions

@<Index0JS Constant Definitions@>=
@<Server Port Assignment@>
@

@<Server Port Assignment@>=
 
/*********************
  CONSTANTS
 *********************/
@<IndexJS Port Assignment@>
@

@node Makefile Additions
@subsection Makefile Additions for @file{index.js}

@<Makefile Filename Definitions Hook@>=
@<Makefile Filename INDEX.JS Hook@>
@

@<Makefile Filename INDEX.JS Hook@>=
INDEX.JS_ALL := index0.js
@

@<Makefile Create Files Targets@>=
${INDEX.JS_ALL} : | ${ROOT}
@

@node Makefile Start Server
@subsection Makefile Start Server
@cindex server, start
@cindex start-server
@cindex run hook

@<Makefile Run Hook@>=
 
####################
# RUN HOOKS        #
####################
.Phony : start-server
start-server :
	cd ${ROOT} && npm run dev
@

@node Route Handlers
@section Express Route Handlers
@cindex route handlers, express
@cindex express route handlers

This section will analyze the @code{app.get} from above.

@table @code
@item app
Express App to register this route handler with

@item get
Watch for incoming requests with this method; other methods could be: 

@itemize
@item
get: get info

@item
post: send info

@item
put: update all properties

@item
delete: delete info

@item
patch: update one or two properties
@end itemize

@item '/'
Watch for requests trying to access the '/' route; could have a
different route, such as '/greeting';

@item req
Object representing the incoming request

@item res
Object representing the outgoing response

@item res.send()
Immediate send some JSON back to whomever made this request
@end table

@node Heroku Deployment
@section Heroku Deployment
@cindex Heroku deployment
@cindex heroku deployment
@cindex deployment, Heroku

This section will be about deploying our application to the Internet via
Heroku, making changes, then redeploying the changes.

@url{https://www.heroku.com, Heroku}

Deployment occurs in two phases, outlined below.  The steps involve,
first, getting signed up to Heroku, installing Heroku's command-line
interface (CLI), creating an app on Heroku, then sending your app's code
to Heroku, at which time Heroku assembles the app and deploys it; then
second, making changes to your app's code, and redeploying to Heroku.

@subheading Deployment Cycles

@itemize
@item
First Time Deploy

@itemize
@item
Create Heroku account; @xref{Heroku Account}

@item
Commit codebase to Git; @xref{Commit to Git}

@item
Install Heroku CLI and create Heroku app; @xref{Install Heroku CLI}

@item
Deploy Heroku app with Git; @xref{Deploying to Heroku}

@item
Heroku deploys project
@end itemize

@item
Subsequent Deploys; @xref{Subsequent Deployment}

@itemize
@item
Commit modified codebase to Git

@item
Deploy modified Heroku App
@end itemize
@end itemize

@node Preparing for Deployment
@subsection Preparing for Deployment
@cindex deployment preparation
@vindex PORT
@cindex dynamic port binding
@cindex port assignment

Preparing for deployment means providing the information that Heroku
will need in order to get the app up and running, such as port
information, the app's runtime environment (required versions of Node
and NPM), the app's entry point, and so forth.

Preparing for deployment also involves obtaining Heroku's command-line
interface for communicating with Heroku from the command-line, which
allows you to log into Heroku, create an app on Heroku, and send code to
the app on Heroku.

@table @b
@item Dynamic Port Binding
Heroku dynamically assigns a port on which our app will listen, so we need
to incorporate that port assignment into our app using an environment
variable that Heroku uses: @samp{process.env.PORT}; in the alternative,
we can use a default port assignment, such as 5000, if we are deploying
locally. 

@<IndexJS Port Assignment@>=
const PORT = process.env.PORT || 5000;
@

@item Specify Node Environment
@cindex node environment
@cindex environment, node
@cindex engines, node and npm
We want to use a specific version of Node, so we need to tell Heroku
which version we want; by default, Heroku uses an older version of Node
which would not be compatible with what this app will be doing.

This is done by adding an @samp{engines} attribute to the
@file{package.json} file, which specify the Node and NPM versions that
we want Heroku to use.  The code should read:

@example
"engines": @{
  "node": "8.1.1",
  "npm": "5.0.3"
@},
@end example

@xref{Sed Utility} and
@pxref{Makefile Sed Utility Additions}

@item Specify Start Script
@cindex start script
Instruct Heroku what command to run to start our server running

Delete the @samp{test} script, and replace it with:

@example
"scripts": @{
  "start": "node index.js"
@},
@end example

@item Craete .gitignore File
@cindex .gitignore file, Heroku

We don't want to include dependencies; Heroku will do that for us 

Add @file{node_modules} to the project's @file{.gitignore} file.
@xref{Heroku Gitignore File}
@end table

@node Sed Utility
@subsubsection Sed Utility

There does not seem to be any easy way to either set up a default
@file{engines} attribute using @code{npm init} or to edit the code using
@file{npm}, so I am here creating a little utility @file{sed} script to
insert the @code{engines} attributes and also change the @file{scripts}
attribute (described next).  This script is deleted by @file{make} after
it has done its work.  The script is called by @file{make} after
@file{npm} initializes and has created the @file{package.json} file.

@subsubheading Sed Utility for Engines Addition

@(util.sed@)=
/scripts/i\
\ \ "engines": {\
\ \ \ \ "node": "8.1.1",\
\ \ \ \ "npm": "5.0.3"\
\ \ },
@

@subsubheading Sed Utility for Scripts Start Addition

@(util.sed@)=
/test/c\
\ \ \ \ "start": "node index.js",\
@

@node Makefile Sed Utility Additions
@subsubsection Makefile Sed Utility Additions
@cindex npm-package-modify

@<Makefile NPM Hooks@>=
 
.Phony : npm-package-modify
npm-package-modify : npm-install
	-sed -i '' -f util.sed ${ROOT}/package.json && rm util.sed
@

@<Makefile NPM@>=
NPM = npm-package-modify
@

@node Heroku Gitignore File
@subsubsection Heroku .gitignore File

@(gitignore@)=
node_modules
@

@<Makefile Move Hook@>=
.Phony : move-gitignore
move-gitignore : ${ROOT}/.gitignore

${ROOT}/.gitignore : | ${ROOT}
	mv gitignore ${ROOT}/.gitignore

# Necessary when install-files is run but .gitignore exists in ROOT
.Phony : rm-gitignore
rm-gitignore: 
	-[ -f gitignore ] && rm gitignore
@

@<Makefile Move Prereqs@>=
MOVE_PREREQS += move-gitignore
@

@<Makefile Clean Hook@>=
	rm -f gitignore
	rm -f *.sed
@

@node Interacting with Heroku
@subsection Interacting with Heroku
@cindex Heroku CLI
@cindex heroku CLI
@cindex interacting with Heroku

@subsubheading Sign Up for Heroku Account
@anchor{Heroku Account}

This section is about deploying to Heroku for the first time.  The first
step is to create a Heroku account.  Go to @url{https://www.heroku.com}
and sign up for a free account.  Then, sign into that account.

@subsubheading Commit Codebase to Git
@anchor{Commit to Git}

By default, Heroku uses a @dfn{Git-based deployment workflow}.  All that
we have to do is commit our codebase to Git.

@subsubheading Create Local Repository and Add Code

@<Makefile Git Targets@>=
.Phony : git-init
git-init : ${ROOT}/.git move-gitignore rm-gitignore

${ROOT}/.git : | ${ROOT}
	cd ${ROOT} && \
	git init && \
	git add . && \
	git commit -m "Initial commit"
@

@example
git add .
git commit -m "initial commit"
@end example

@subsubheading Install Heroku CLI
@anchor{Install Heroku CLI}

The Heroku CLI will allow us to create a brand new application on Heroku
from the command line.  Go to
@url{https://devcenter.heroku.com/articles/heroku-cli}.  Install the
Heroku CLI: @file{heroku}.  You should be able to obtain an answer to
the query @code{heroku --version}, such as

@verb{|heroku-cli/6.14.39-addc925 (darwin-x64) node-v9.2.0|}

@node Deploying to Heroku
@subsection Deploying to Heroku
@cindex Heroku deployment
@cindex heroku deployment
@cindex deploy
@cindex deployment, Heroku

Will now create a new Heroku app using the Heroku CLI.  This involves
logging into Heroku from its CLI (@code{heroku login)}, creating an app
on Heroku (@code{heroku create)}, receiving connection information
(deployment target and repo url), creating a remote @file{heroku} Git
branch, and finally pushing our local app to the Heroku Git repository
on a Heroku branch (@code{git push heroku master)}.

Heroku should automatically deploy the app when it receives the pushed
local repo.

@subheading Login to Heroku

Type on the command-line: @code{heroku login}

Now enter your Heroku credentials: @samp{email} and @samp{password}. 
This will start the Heroku CLI and place you at its prompt.

@subheading Create Heroku App

Type at the command-line:

@code{heroku create}

Heroku will process the command and produce two links.

@enumerate
@item
@cindex heroku app url
The new app's URL,
e.g. @indicateurl{https://agile-bayou-65260.herokuapp.com/}

@item
@cindex deployment target
Our @dfn{deployment target}, a Git repo that we can push our local
server to,
e.g. @indicateurl{https://git.heroku.com/agile-bayou-65260.git}; when
Heroku receives our pushed app's repo, it will deploy it.

@item
Add @file{remote} Heroku branch to Git:@* @code{git remote add heroku
https://git.heroku.com/agile-bayou-65260.git}
@end enumerate

@subheading Deploy App to Heroku

Type at the command-line:

@code{git push heroku master}

Heroku should indicate that it is processing the information and
deploying the app using Node.  Now open the app by typing:

@code{heroku open}

@node Subsequent Deployment
@subsection Subsequent Deployment
@cindex deployment, subsequent
@cindex deployments, followup
@cindex redployment
@cindex updated codebase, deployment

Subsequent deployments to Heroku involve making changes to your app's
code base, commiting the changes to Heroku, and pushing those changes to
Heroku.  Heroku will recompile and redeploy when it receives the updated
code.

@enumerate
@item
Make changes to codebase

@item
Commit codebase to Git

@example
git add .
git commit -m "message"
@end example

@item
Push updated codebase to Heroku

@example
git push heroku master
@end example

@end enumerate

Heroku will take the changes and redeploy.

@node Authentication
@chapter Authentication with Google OAuth
@cindex oauth
@cindex OAuth
@cindex authentication

This is the first step in how a User will interact with this
application.  This is a completely server-side feature.

@node Intro to Google OAuth
@section Introduction to Google OAuth
@cindex oauth, introduction
@cindex OAuth, introduction

On the surface, OAuth will start with a button that says @samp{Sign in
with Google}.  This system uses the OAuth certification process, which
we can tap into.

@node OAuth Flow
@section The OAuth Flow
@cindex oauth flow
@cindex OAuth flow

@itemize
@item
Client

@itemize
@item
User clicks ``login''

@item
User is directored to @url{localhost:5000/auth/google} (on the server);
this is an arbitrary name; nothing inherently important about the name.

@item
User's browser receives cookie from server and is kicked back to
localhost:3000 and is logged in

@item
User requests some resources from the server API
@end itemize

@item
Server

@itemize
@item
The server receives and forwards the User's request on to Google to
allow the User to grant Google permission to reveal the User's information
to the application; the server sends along an @samp{app id} to Google:
@url{google.com/auth?appId=123}

@item
The server receives a code from Google's redirect as a parameter:
@url{localhost:5000/auth/google/callback?code=456}

@item
The server sends the request back to Google with @samp{code} and its
value included;

@item
The server receives details about the User from Google and creates a new
record in its database

@item
Sends a User ID in a cookie for this User

@item
The server receives a request from the User with a cookie that has the User
ID 
@end itemize

@item
Google

@itemize
@item
Google receives User's request and asks the User if s/he grants
permission

@item
User grants permission

@item
Google then redirects back to the server at
@url{localhost:5000/auth/google/callback?code=456}; this redirect URL is
again not inherently important; what is important is the parameter
@samp{code} and its value;

@item
Google receives 2nd request from the server with @samp{code} in the URL
and replies with details about this user;
@end itemize

@end itemize

@node PassportJS
@section PassportJS
@cindex passportjs, overview

@url{https://passportjs.org}

Will be using a helper library called @file{PassportJS} to create the
OAuth authentication flow.  This library encapsulates many of the steps
outlined in the flow in the previous section:

@node PassportJS Overview
@subsection PassportJS Overview
@cindex passportjs overview

@subheading On the server side, it encapsulates the following:

@itemize
@item
Forward User's initial request to Google

@item
Receive Google's initial response with an authorization code

@item
Forward User's authenticated request back to Google
@end itemize

@subheading On Google's side, it encapsulates every step:

@itemize
@item
Receive initial request from the server and asks User if s/he grants
permission for it to reveal the User's information

@item
Returns a code to the server indicating that the User has authorized it
to reveal information

@item
Receives second request with authorization from the server, and reveals
the requested User's information
@end itemize

@node Passport Library Components
@subsection Passport Library Components
@cindex passportjs library components

@table @strong
@item passport
General helpers for handling auth in Express apps

@item passport strategy
Helpers for authenticating with one very specific method
(email/password, Google, Facebook, etc)
@end table

Passport utilizes different @samp{strategies} to authenticate with
specific organizations.  Learning how to utilize one strategy will make
utilizing other strategies easy.

@node Passport Installation
@subsection Passport Installation
@cindex passport install
@cindex install passport

Will be installing PassportJs (@file{passport.js}, and the Google
strategy (@file{passport-google-oauth20}, and then wiring them up
to our application.

@subsubheading Install PassportJS and Its Google Strategy

@<Makefile NPM_INSTALLS@>=
NPM_INSTALLS += passport passport-google-oauth20
@

@node Incorporate Passport into IndexJS
@subsection Incorporate Passport into IndexJS
@cindex passport and index.js
@cindex index.js and passport

The file @file{index.js}, our @samp{server} file for the moment, needs
to be refactored so that it imports the @file{passport} module and also
the Google @file{strategy} code (there are other strategies that we can
use later, such as Facebook and LinkedIn), and then hooks into them.
Because the Google strategy code exports more functions than we need, we
can specifically require only the function that we will be using, in
this case @code{Strategy}.

@subsubheading Passport and Google Strategy Imports

@<Import Passport@>=
const passport = require('passport');
@

@<Import GoogleStrategy@>=
const GoogleStrategy = require('passport-google-oauth20').Strategy;
@

@subsubheading Google Strategy
@cindex google strategy

The @file{passport} module needs to be given a @dfn{strategy} in order
to work.  At this point, we are using the Google strategy, and so we
will tell @file{passport} to @samp{use} it.  In a future section
(@pxref{Google Strategy Options}) we will give our @samp{GoogleStrategy}
object some configurations options to use, and so to make things simpler
those will be added here at this point, even though we discuss them
later.

@anchor{Use GoogleStrategy Options}
@<Passport Header@>=
 
/*********************
  PASSPORT
 *********************/
@

@<Passport Use GoogleStrategy0@>=
@<Passport Header@>
passport.use(
  new GoogleStrategy(
    @<GoogleStrategy Options0@>
  )
)
@

@node Refactored IndexJS for Passport
@subsubsection Refactored @file{index.js} for Passport
@cindex index.js refactored for passport

@(index1.js@)=
@<Index1JS Requirements@>
@<Index0JS Constant Definitions@>
@<Create App@>
@<Create Google Auth Route Handlers@>
@<Passport Use GoogleStrategy0@>
@<Start App@>
@

@<Makefile Filename INDEX.JS Hook@>=
INDEX.JS_ALL += index1.js
@

@<Makefile Link Target Hook@>=
	ln -f ${ROOT}/index1.js ${ROOT}/index.js
@

@subsubheading IndexJS Requires

@<Index1JS Requirements@>=
@<Index0JS Requirements@>
@<Import Passport@>
@<Import GoogleStrategy@>
@

@node Google OAuth API
@section Enable Google OAuth API
@cindex google oauth api
@cindex api, google oauth
@cindex api credential
@cindex google project, create

We need to pass some additional configuration options to the Google
strategy: a @samp{client id} and a @samp{client secret}.  These are
provided to us by Google's OAuth service.  Our application must be
signed up, or registered, with the Google OAuth API.

@node Create Google Project
@subsection Create Google Project

Go to @url{https://console.developers.google.com} to create a Google
project to use with authentication.  Create a new project and name it
@samp{emaily-dev}.  Now, do the following things:

@table @strong
@item Enable the Google OAuth API
@itemize
@item
click the button @samp{Enable APIs and Services}

@item
search for @key{google+}

@item
choose @samp{Google+ API}

@item
click @kbd{Enable}
@end itemize

@item Generate an API credential.
@itemize
@item
Click on the button @key{Create credentials};

@item
choose @samp{client id},

@item
then @key{Configure consent screen};

@item
fill out the @samp{Product name} with @samp{emaily-dev}

@item
and click @kbd{Save};

@item
for @samp{Application type}, choose @samp{Web application}

@item
Under @samp{Restrictions},

@table @i
@item Authorized JavaScript origins
@url{http://localhost:5000}

@item Authorized redirect URIs
@url{http://localhost:5000/*}
@end table

@item
Google will present a pop-up with a @samp{Client ID} and a @samp{Client
Secret}; copy these items and save them someplace safe (@pxref{Securing
API Keys}).

@itemize
@item Client ID: 

@item Client Secret: 
@end itemize

@end itemize

@end table

@node Securing API Keys
@unnumberedsubsec Securing API Keys
@cindex api keys, securing
@cindex keys
@cindex secret keys
@cindex client secret
@cindex clientSecret
@cindex client id
@cindex clientID

@table @emph
@item clientID
Public token --- identifies our application to Google servers; can share
this with the public

@item clientSecret
Private token --- must keep it hidden from the public
@end table

It is important not to make the client secret a part of a GitHub repo.
At this point, we will implement a short-term solution to keeping the
secret hidden.

@itemize
@item
Create a new folder inside the root folder (@file{server}) and name it
@file{config}

@<Makefile Directory Definitions Hook@>=
CONFIG_DIR := ${SOURCE_DIR}/config
@

@<Makefile Directory Creation Hook@>=
.Phony : ${CONFIG_DIR}
${CONFIG_DIR} : | ${ROOT} ${PREFIX} ${SOURCE_DIR}
	mkdir -p ${CONFIG_DIR}
@

@item
Inside the folder @file{config}, create a file and name it
@file{keys.js}

@<Makefile Filename Definitions Hook@>=
KEYS := keys.js
@

@<Makefile Create Files Targets@>=
${KEYS} : | ${CONFIG_DIR}

@

@<Makefile Move Hook@>=
.Phony : move-keys-to-config
move-keys-to-config : ${KEYS}
	mv ${KEYS} ${CONFIG_DIR}
@

@<Makefile Move Prereqs@>=
MOVE_PREREQS += move-keys-to-config
@

@item
Create inside @file{keys.js} the object named @code{module.exports}

@item
Inside @code{module.exports}, create an attribte called
@code{googleClientID} and make its value the Google client id that was
generated in the last step;

@item
make an attribute called @code{googleClientSecret} make its value the
Google client secret generated in the last step;

@item
never commit the file @file{keys.js} to Git by adding its name to the
@file{.gitignore} file

@end itemize

@subheading @file{keys.js} @code{module.exports} Object
@findex keys.js

@(keys.js@)=
module.exports = {
  @<Keys_JS Internals@>
}

@

@<Keys_JS Internals@>=
@<Google Client Secret Keys@>
@<Google Callback URL@>
@

@<Google Client Secret Keys@>=
  googleClientID: process.env.WEB_CLIENT_1_ID,
  googleClientSecret: process.env.WEB_CLIENT_1_SECRET,
@

@subheading @file{.gitignore}
@findex .gitignore

@example
keys.js
@end example

@node Google Strategy Options
@subsection Google Strategy Options
@cindex google strategy options

@subsubheading Require Keys

Now that we have the Google API keys, we need to import the keys into
our @file{index.js} file by using the @code{require} keyword and then
pass the keys to our @code{GoogleStrategy} object so it can use them
when authorizing our app with Google.

@<Import Config Keys@>=
const keys = require('./src/config/keys');
@

@<Index1JS Requirements@>=
@<Import Config Keys@>
@

@subsubheading Google Strategy Keys and Callback URI
@cindex callback
@cindex callback route and function
@cindex access token
@cindex token, access

The @code{GoogleStrategy} object needs to know the @code{clientID} and
@code{clientSecret}, as well as a @code{callback} route.  These are
obtained from the @file{keys.js} file imported above.  There also needs
to be a @code{callback} function that receives Google's @code{access
token} as a parameter.  More parameters can be included, but for now,
just log the access token in the callback.  In other words, the
@samp{GoogleStrategy} object takes two parameters, options and callback,
and the callback takes one parameter, an @samp{access token}:

@subsubheading Google Strategy Object

This code reads from the @file{keys.js} file.

@<Google Strategy Object@>=
{
  clientID: keys.googleClientID,
  clientSecret: keys.googleClientSecret,
  callbackURL: keys.googleCallbackURL
}
@

@subsubheading Google Strategy Callback URL

This callback URL is placed into the @file{keys.js} file.

@<Google Callback URL@>=
  googleCallbackURL: '/auth/google/callback',
@

@subsubheading Google Strategy Callback Function

As a callback, for now, just log the access token.  This will be
expanded later.

@<Google Strategy Callback Function0@>=
(accessToken) => {
  console.log(accessToken);
}
@

Here are the combined GoogleStrategy options: keys and callback
function.  

@<GoogleStrategy Options0@>=
@<Google Strategy Object@>,
@<Google Strategy Callback Function0@>
@

@xref{Use GoogleStrategy Options}

@node Testing OAuth
@section Testing OAuth
@cindex oauth testing
@cindex testing, oauth

At this point we have put together the minimum amount of information for
the Google strategy to work.  The Google Strategy receives some
configuration options and a lambda function as a callback to handle the
access token received from Google.  We will ignore the callback for the
time being and just log it to the console.

When a User clicks @key{Login}, a route handler should direct that User
to the Google Strategy OAuth authorization mechanism, which is managed
by @file{PassportJS}.  Therefore, we need to create a route handler to
handle this event.  The callback function will utilize the
@file{passport} functionality.

@node Review OAuth Flow
@subsection Review of OAuth Flow

@itemize
@item
User clicks @key{Login}

@item
Directed to the Express server at the URL
@url{http://localhost:5000/auth/google}

@item
The Express server will then forward the User to the Google server

@item
User is asked to grant permission for the App to access their
information

@item
Assuming the User does grant permission, the User will be sent back to
the Express server at the URL and with an authorization code:
@url{http://localhost:5000/auth/google/callback?code=456}  
@end itemize

@node Route Handler Implementation
@subsection Google Strategy Route Handler Implementation
@cindex implementation, route handler, google strategy

Therefore need to configure the server to send and receive the User, as
per the above.  This is done by creating a route handler at
@code{/auth/google} that sends the User into the Passport object for
processing and then receives the response from Google at
@code{/auth/google/callback} with a special authorization code as a
query string.

Instead of giving the route handler a callback, give it a Passport
function call into Passport's @code{authenticate} method, with two scope
arguments of @samp{profile} and @samp{email}.  Why @samp{google} as an
argument to @code{authenticate}?  Because the class
@file{GoogleStrategy} has some internal code that sets this string to
Google's oauth strategy code.  The @samp{scope} arguments tell Google
what portions of the User's profile the application is seeking to
access.  These two scopes are not actually needed for this application;
this is just an example of how to request specific scopes.

@<Create Google Auth Route Handlers@>=
@<Create Initial Route Handlers@>
app.get(
  '/auth/google',
  passport.authenticate('google', {
    scope: ['profile', 'email']
  })
);
@

@node Authorized Redirect URIs
@subsection Authorized Redirect URI's
@cindex redirect uri

If the code is run at this point, it will successfully jump into
Google's OAuth authorization section, but then will throw the error
@samp{redirect_uri_mismatch}.  This is caused because we have not
registered this redirect uri with Google.  Google will not allow a
redirect without this authorization as a security feature.

To allow this callback, log into Google API's, tab into
@kbd{credentials}, and add the callback uri to @samp{Authorized redirect
URIs}.

@node OAuth Callbacks
@subsection OAuth Callbacks
@cindex oauth callbacks

Now we need to set up another route handler to handle the redirect from
Google with the authorization code.  When the callback is triggered, it
will forward to Passport the code that is embedded in the uri that is
received from Google.  While the @code{authenticate} method call looks
to be the same, the difference is that the uri contains the
authorization code, which is forwarded to Google by this call.

@<Create Google Auth Route Handlers@>=
app.get('/auth/google/callback',
  passport.authenticate('google')
);
@

@node Tokens
@subsection Access and Refresh Tokens
@cindex tokens, access and refresh

At this point, we can start to take a look at Google Strategy's callback
function.  Currently it is just logging an access token to the console.
Let us log a couple more items to the console using a slightly modified
callback function.

@<Google Strategy Callback Function1@>=
  (accessToken, refreshToken, profile, done) => {
    console.log('access token', accessToken);
    console.log('refresh token', refreshToken);
    console.log('profile', profile);
  }
@

@subsubheading Create New Options Object

Combine the @samp{strategy} object with the @samp{callback} function:

@<GoogleStrategy Options1@>=
@<Google Strategy Object@>,
@<Google Strategy Callback Function1@>
@

@subsubheading Use New Options

Place the new options into the passport @samp{use} method:

@<Passport Use GoogleStrategy1@>=
@<Passport Header@>
passport.use(
  new GoogleStrategy(
    @<GoogleStrategy Options1@>
  )
);
@

@subsubheading New @file{index.js} File with new Options

Create a new @file{index.js} file with the modified GoogleStrategy
callback:  

@(index2.js@)=
@<Index1JS Requirements@>
@<Index0JS Constant Definitions@>
@<Create App@>
@<Create Google Auth Route Handlers@>
@<Passport Use GoogleStrategy1@>
@<Start App@>
@

@node OAuth Tokens Output
@subsubsection OAuth Tokens Output
@cindex tokens output

When the server is started and we visit the
@url{http://localhost:5000/auth/google} url, then it should appear that
the server is hanging, but the server will have received @samp{access
token} and @samp{profile} from Google and logged their values to the
terminal.  These tokens contain our @dfn{identifying information}, i.e.,
our name, email, and other such items.  This is the heart of what we are
getting at in this OAuth section.

@subsubheading Access Token

We could use this access token to access and modify the user's
information (but we are not doing so in this tutorial).

@subsubheading Refresh Token

The refresh token allows us to refresh the access token after it
expires.

@subsubheading Profile

Contains our identifying information.

@subsubheading Conclusion of Passport

This basically concludes with the canned Passport functionality.  The
next steps involve storing the User's data in a data base and logging
them into our application.

@node Tokens Output
@subsubsection Tokens Output

@verbatim
access token
ya29.GlszBVwKKRnKIEK8ILFz4wRGtLgNJEHrdC1lKYHYqH2FMmVN2G3t87ohGKh6eSJUP7QaDhyU0Lgaj55Tqw1bwkI3MGANdeT7LIy8mekV_2eacvnbz_Va47TNKvww

profile { id: '111187604413365458197',                       
  displayName: 'wl Harvey',                                                                                                                                                                                 
  name: { familyName: 'Harvey', givenName: 'wl' },                                                                                                                                                          
  emails: [ { value: 'pinecone062@gmail.com', type: 'account' } ],                                                                                                                                          
  photos:                  
   [ { value: 'https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/photo.jpg?sz=50' } ],
  gender: undefined,                                              
  provider: 'google',                                                
  _raw: '{\n "kind": "plus#person",\n "etag":
  "\\"ucaTEV-ZanNH5M3SCxYRM0QRw2Y/HQ4l1fcTNzqAdBbiIPZ0TrDpLkg\\"",\n
  "emails": [\n  {\n   "value": "pinecone062@gmail.com",\n   "type":
  "account"\n  }\n ],\n "objectType": "person",\n "id":
  "111187604413365458197",\n "displayName": "wl Harvey",\n "name": {\n
  "familyName": "Harvey",\n  "givenName": "wl"\n },\n "image": {\n
  "url":
  "https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/photo.jpg?sz=50",\n
  "isDefault": t  _raw: '{\n "kind": "plus#person",\n "etag":
  "\\"ucaTEV-ZanNH5M3SCxYRM0QRw2Y/HQ4l1fcTNzqAdBbiIPZ0TrDpLkg\\"",\n
  "emails": [\n  {\n   "va-bash: =: command not found
  
@end verbatim

@node Makefile Additions New Options Object
@subsubsection Makefile Additions for New Options Object

@<Makefile Filename INDEX.JS Hook@>=
INDEX.JS_ALL += index2.js
@

@<Makefile Link Target Hook@>=
	ln -f ${ROOT}/index2.js ${ROOT}/index.js
@

@node Nodemon
@section Nodemon Setup
@cindex nodemon

Let's install the @file{nodemon} package; to do that we just add the
package @file{nodemon} to our @code{npm install} variable:

@<Makefile NPM_INSTALLS@>=
NPM_INSTALLS += nodemon
@

We also need to add a script to the @file{package.json} @samp{scripts}
section, which we can do simply by tacking this onto the end of our
current @file{util.sed} script created earlier (but first append a comma
and newline to the end of the prior script to allow this to work):

@(util.sed@)=
\ \ \ \ "dev": "nodemon index.js &"
@

@node MongoDB
@chapter Adding MongoDB
@cindex mongodb
@cindex MongoDB

In this chapter, we will first refactor our code by splitting out much
of the logic currently in @file{index.js} into separate directories and
files.  Then, we will review authentication theory and signing in of
Users, both for the first time and subsequent logins.  Then we will
begin to incorporate MongoDB and Mongoose into our project.

We will introduction MongoDB and Mongoose on a conceptual level, then
set up a MongoDB deployment on @file{mLab} and obtain configuration data
to use with our app.  After we get the configuration data, we will
configure out app to actually connect to the @file{mlab} MongoDB
database.

The third phase will then discuss how to use Mongoose to save a User's
Google ID in our Mongo database using Schemas, Model Classes and
Instances.  We will see that requiring all of the code must be done in a
particular order to avoid some difficult errors.  The callback function
in GoogleStrategy will receive the User's Google ID, and save it to a
collection that was previously defined in a schema.

@node Server Refactor
@section Server Structure Refactor
@cindex server, refactor

This is a good point to refactor our code.  There is no consensus in the
Node community on how best to structure projects.  The way chosen in
this project is one possible way, not necessarily the best way for all
projects, but one that works well here.

The restructure will create several new directories and transfer some
code into new files inside these new directories.  The next section
describes the new directories and what will be placed inside them.

@node Structure Diagram
@subsection Structure Diagram
@cindex diagram, structure

The @file{server} directory holds all of our server-side logic.

@subsubheading @file{server directory}

@table @file
@item src
Holds all subdirectories and associated JS code

@table @file
@item config
Protected API keys and settings; additional secret keys will be placed
into the @file{keys.js} file.

@item routes
All route handlers grouped by purpose; the current route handlers will
go into a @file{authRoutes.js} file.

@item services
Helper modules and business logic; at this point the @file{passport}
code will go into this directory.

@end table

@item index.js
Helper modules and business logic; @file{index.js} will remain the app's
entry point, but much of its current code will be refactored as
described above.

@end table

@node New Directories
@subsection New Directories
@cindex refactor, new directories

Will start off by creating two new directories inside the
@file{server/src} directory: @file{routes} and @file{services}.

@itemize
@item
@b{routes}: to hold the route handlers;

@xref{authRoutes_js}

@<Makefile Directory Definitions Hook@>=
ROUTES := ${SOURCE_DIR}/routes
@

@<Makefile Directory Creation Hook@>=
.Phony : ${ROUTES}
${ROUTES} :
	mkdir -p ${ROUTES}
@

@item
@b{services}: to hold the Passport code;

@xref{passport_js}

@<Makefile Directory Definitions Hook@>=
SERVICES := ${SOURCE_DIR}/services
@

@<Makefile Directory Creation Hook@>=
.Phony : ${SERVICES}
${SERVICES} :
	mkdir -p ${SERVICES}
@

@end itemize

@node New Files in New Directories
@subsection New Files in New Directories

@node authRoutes_js
@subsubsection @file{authRoutes.js}
@cindex authRoutes.js

@file{authRoutes.js} will hold the route handling code that is
currently in @file{index.js}.

This file (@file{authRoutes.js}) needs the @file{app} server in order to
set up the routes, and so this code will be wrapped in an arrow function
with one parameter, the @file{app} variable.  @file{index.js} will
import this function, then call it with the @file{app} that it has
created.

@(authRoutes.js@)=
@<Import Passport@>
module.exports = (app) => {
  @<Create Google Auth Route Handlers@>
  @<AuthRoutes Route Handler Hook@>
}
@

@subsubheading authRoutes in index.js

The above code must be be imported into @file{index.js}, which must
execute the exported function with a parameter of the @file{app}.

@<Initialize AuthRoutes With App@>=
 
/*-------------------
 * Initialize authRoutes
 *-------------------*/
require('./src/routes/authRoutes')(app);
@

This code moves the file @file{authRoutes.js} into the @file{routes}
directory.

@<Makefile Move Hook@>=
.Phony : move-authRoutes
move-authRoutes : | ${ROUTES}
	mv -f authRoutes.js ${ROUTES}
@

@<Makefile Move Prereqs@>=
MOVE_PREREQS += move-authRoutes
@

@node passport_js
@subsubsection @file{passport.js}
@cindex passport.js

@file{passport.js} file holds all of the @file{passport} logic to
authenticate the User and authorize this app to receive the User's
personal information.  This file needs to import @file{passport},
@file{GoogleStrategy}, and the secret key information.  Then, it
@code{use}'s the @file{GoogleStrategy}.

@(passport.js@)=
@<Passport Requirements@>
@<Passport Use GoogleStrategy2@>
@

@<Passport Requirements@>=
@<Import Passport@>
@<Import GoogleStrategy@>
@<Import Config Keys2@>
@

The path to the @file{keys.js} file has changed slightly.

@<Import Config Keys2@>=
const keys = require('../config/keys');
@

This moves the @file{passport.js} file into the @file{src/services}
directory.  

@<Makefile Move Hook@>=
.Phony : move-passport
move-passport : | ${SERVICES}
	mv -f passport.js ${SERVICES}
@

@<Makefile Move Prereqs@>=
MOVE_PREREQS += move-passport
@

@node index3_js
@subsubsection @file{index3.js}
@cindex index3.js

Much of the code currently in @file{index.js} will be moved out, which
means much of its imports will not be needed and can be removed.  This
file still needs to set up and start the application's server,
@file{app}.  It also needs to call the @file{authRoutes.js} file and
send it the @code{app} that it has created.  Finally, it needs to
connect to the @file{mLab} Mongo database we will create shortly.

To allow code down the line to hook into our app, we will give it a
@samp{Use Hook} right after it is created.

@(index3.js@)=
@<Index3JS Requirements@>
@<Server Port Assignment@>
@<Create App@>
@<App Use Hook@>
@<Initialize AuthRoutes With App@>
@<Start App@>
@<Connect Mongoose@>
@

@anchor{Tricky Order}
In many cases, the order of importing is not important.  However,
because of the way the @file{passport.js} file will be implemented,
there is an ordering issue that crops up later.  @file{index.js} must
call both @file{passport.js} and @file{User.js} in order to execute
them.  The code in @file{User.js} creates a Class that
@file{passport.js} uses, and therefore @file{User.js} must be
@code{require}d first, and is included here even though we have not yet
discussed it. @xref{Model Class File User}.  

@<Index3JS Requirements@>=
@<Index0JS Requirements@>
@<Require Mongoose@>
@<Import Config Keys@>
@<Import Model User@>
@<Import Passport1@>
@

The @file{passport.js} file does not export anything, but it still needs
to be executed, and that is the job of @file{index.js}.

@<Import Passport1@>=
require('./src/services/passport');
@

This code links the current @file{index3.js} as @file{index.js}.

@<Makefile Link Target Hook@>=
	ln -f ${ROOT}/index3.js ${ROOT}/index.js
@

@<Makefile Filename INDEX.JS Hook@>=
INDEX.JS_ALL += index3.js
@

@node Authentication Theory
@section The Theory of Authentication
@cindex authentication theory
@cindex login request

The User wants to be logged into our app, and so sends a @code{login}
request.  The server logs in the User, either as a new User or as a
returning User, by returning a token unique to that User.  Then the app
sends a request to the server and requests some information about the
User.  As part of that request, it sends along the token that it
received from the server.

@cindex stateless, HTTP

However, on its own, HTTP is @dfn{stateless}, that is, knows nothing
about what has happened in the past.  All HTTP requests are equal and
clueless.  Therefore, without more, the server cannot know anything
about a User that logged in previously.

@cindex cookie-based authentication
@cindex Set-Cookie
@cindex token

Therefore, this app will use @dfn{cookie-based} authentication.  The
server will send back a response that includes a @code{Set-Cookie}
key-value pair in the header.  The value will be set to some unique
random token assigned to this user.  The browser will automatically save
the token in its memory and send the token to the server with every
request it makes.  The server will be able to see this token and know
which User it applies to.

@node Signing in Users
@section Signing in Users with OAuth
@cindex users, sign in
@cindex oauth flow
@cindex profile id
@cindex id, profile

This is a high-level view of the OAuth flow.

The User wants to log in, so our app sends the User to Google to sign
in, and then Google sends back to the server an access token and a
profile, among other things.  Thereafter, the User signs out, and then
signs in again.  The server needs to determine whether this a first
login, or a subsequent login.  We can use profile's @samp{id} value.
This is actually Google's sole purpose---provide the server with a
unique identification key based upon User.

The server keeps a MongoDB database of Users and Users' @samp{id}s.
When a User logs in, the server will receive an @samp{id} and check its
database against that @samp{id}.  If the User is not found, the server
will add this User to the database.  If the User is found, the server
will not add the User, but will instead have a reference to the User's
data.  

@subheading Mongo --- Mongoose Connection

@itemize
@item
Install Mongo / Install Mongoose

@item
Identify Users

Need to be able to identify Users who sign up and return to our
application.  We want to save the @samp{id} in their Google in our
database 
@samp{profile}

@item
Mongo Collection (Mongoose @code{model class})

Use Mongoose's @code{model class} to create a new collection in Mongo
called @code{users}

@item
New User

When a User signs in, save a new record to the @code{users} collection 
@end itemize

@node MongoDB Intro and Setup
@section Introduction to MongoDB and Setup
@cindex mongodb introduction
@cindex mongodb setup
@cindex setup mongodb

How Mongo internally stores information.

@itemize
@item
MongoDB

@itemize
@item
Collection 1

@itemize
@item
Record 1

@item
Record 2

@end itemize

@item
Collection 2

@itemize
@item
Record 1

@item
Record 2
@end itemize

@item
Collection 3

@itemize
@item
Record 1

@item
Record 2
@end itemize

@end itemize

@end itemize

Mongo does not enforce any particular schema inside collections or
records, so each can be completely independent of every other one.

@subheading Mongoose

@itemize
@item
Mongoose

@itemize
@item
Model Class 1

@itemize
@item
Model Instance 1

@item
Model Instance 2
@end itemize

@item
Model Class 2

@itemize
@item
Model Instance 1

@item
Model Instanc 2
@end itemize

@end itemize

@end itemize

Mongoose's Model Class corresponds to MongoDB's Collection.

Mongoose's Model Instance corresponds to MongoDB's Record

@node MongoDB Setup
@subsection MongoDB Setup
@cindex mongodb setup
@cindex setup, mongodb

In general there are two different ways to set up MongoDB:

@enumerate
@item
Locally on your machine

@item
Hosted (e.g., by @file{mLab}); this method should be easier, so will go
through the steps to set up MongoDB on @file{mLab}.
@end enumerate

This tutorial will present the second method because it is basically
easier.  

@node MongoDB on mLab
@subsection Set Up MongoDB on @file{mLab}
@cindex mLab, mongodb

Follow the following steps to create an @file{mLab} account and deploy a
new Mongo database.

@subsubheading mLab

@enumerate

@item URL

@url{https://mlab.com}

@item Create New Account on  @file{mLab}

@item Log Into Account

@item Dashboard

@item Create New Database

Create a new database using @kbd{Create new} button.

@item Creation Wizard

@item Choose Plan Type

Choose Plan Type @code{Sandbox} for free using AWS; pick a Region (US
East)

@item Database Name

Enter a database name--- @file{lolh-emaily-dev}

@item Submit Order

@item New Deployment

New deployment appears on deployments page; click it

@item Open Database

Opens to a database page

@item Create Database User

Create a database user by clicking @kbd{Users} button, then @kbd{Add
database user} button

Modal pops up to input database user name and password

The database user should appear in the Database Users section

@end enumerate

@node Database Information
@subsection Database Information
@cindex database information

This information is provided by @file{mLab} at the conclusion of the
setup procedure.

@table @strong
@item Mongo Shell Template
@verb{|mongo ds239587.mlab.com:39587/lolh-emaily-dev -u <dbuser> -p <dbpassword>|}

@item MongoDB URI Template
@verb{|mongodb://<dbuser>:<dbpassword>@ds239587.mlab.com:39587/lolh-emaily-dev|}

@item Database Host
ds239587.mlab.com

@item Database Port
39587

@item Database Name
lolh-emaily-dev

@item Databse User
pinecone062_user

@item Databse User Password
@dots{}

@item MONGODB_URI
@verb{|mongodb://pinecone062_user:***@ds239587.mlab.com:39587/lolh-emaily-dev|}

@end table

@node mLab Driver Examples
@subsection mLab MongoDB Language Center---Driver Examples
@cindex language center
@cindex driver examples

@url{http://docs.mlab.com/languages/}

mLab is happy to provide driver examples in many of the major languages:
C#, Java, Node.js, PHP, Python, and Ruby.

These examples should run outright after you install the appropriate
drivers and insert your MongoDB URI. For additional information see

@url{https://docs.mongodb.com/v3.2/applications/drivers/}

Currently, we illustrate a simple connection with authentication and
query examples.

@table @file{}
@item Node.js

The officially supported Node.js Native driver for MongoDB:
@url{https://docs.mongodb.com/ecosystem/drivers/node-js/}

@item mongolab/mongodb-driver-examples:

@url{https://github.com/mongolab/mongodb-driver-examples/blob/master/nodejs/nodeSimpleExample.js}

@item Mongoose

Mongoose, an Object Document Mapper (ODM) for MongoDB:

@url{https://github.com/mongolab/mongodb-driver-examples/blob/master/nodejs/mongooseSimpleExample.js,
Mongoose CRUD example}

@url{http://blog.mlab.com/2014/04/mongodb-driver-mongoose/, Mongoose
Tips & Tricks (from mLab’s blog)}

@end table

@node Connect Mongoose to Mongo
@section Connecting Mongoose to MongoDB
@cindex mongoose, connecting to mongodb

In order to connect Mongooose to MongoDB, perform the following steps:

@enumerate
@item
Install the @file{mongoose} npm package (@pxref{mongoose npm package})

@item
Require Mongoose in our @file{index.js} file (@pxref{require mongoose
driver})

@item
Place MongoDB's URI into the @file{keys.js} config file (@pxref{MongoDB
URI})

@item
Call Mongoose's @code{connect} method to connect to MongoDB
(@pxref{Connect to MongoDB})
@end enumerate

@node mongoose npm package
@subsection Install the @file{mongoose} driver in @file{packages}.

@<Makefile NPM_INSTALLS@>=
NPM_INSTALLS += mongoose
@

@node require mongoose driver
@subsection Require the @file{mongoose} driver in our application:

@<Require Mongoose@>=
const mongoose = require('mongoose');
@

@node MongoDB URI
@subsection MongoDB URI

Connect to the @file{mLab} MongoDB instance at the correct MongoDB URI
given by @file{mLab}, of the form:

@verb{|mongodb://<dbuser>:<dbpassword>@ds239587.mlab.com:39587/lolh-emaily-dev|}

The URI is placed inside the @file{keys.js} file in the @file{config}
directory.

@<Keys_JS Internals@>=
@<MongoDB URI@>
@

@<MongoDB URI@>=
  mongoURI: 'mongodb://pinecone062_user:Pinus-sabiniana@ds239587.mlab.com:39587/lolh-emaily-dev',
@

@node Connect to MongoDB
@subsection Connect to MongoDB
@cindex mongoose connect
@cindex connect to mongodb, mongoose

Finally, have @file{mongoose} call its @code{connect} method to connect
to the MongoDB database.

@<Connect Mongoose@>=
 
/********************
 * MongoDB
 ********************/
mongoose.Promise = Promise;
mongoose.connect(keys.mongoURI, {
  @<Use Mongoose Options@>
})
@

@subsubheading Mongoose Connection Options

The Mongoose connection method takes an object of options; need to use
at least one option, @code{useMongoClient: true}.

@<Use Mongoose Options@>=
@<Use MongoClient@>
@

@<Use MongoClient@>=
useMongoClient: true,
@

@node Mongoose Model Classes
@section Mongoose Model Classes
@cindex model classes, mongoose
@cindex model class, mongoose

Need to find a suitable location for adding code to create the Mongoose
model classes.  This code does not belong inside our @file{index.js}
because that file is dedicated to booting up our server.  Add a new
directory called @file{models}, and inside this directory add a new file
called @file{User.js}

@node models Directory
@subsection @file{models} Directory
@cindex models directory

@<Makefile Directory Definitions Hook@>=
MODELS := ${SOURCE_DIR}/models
@

@<Makefile Directory Creation Hook@>=
.Phony : ${MODELS}
${MODELS} :
	mkdir -p ${MODELS}
@

@(User.js@)=
/* User.js
 * Mongoose Model Classes
 */
@

@<Makefile Move Hook@>=
.Phony : move-User
move-User: | ${MODELS}
	mv -f User.js ${MODELS}
@

@<Makefile Move Prereqs@>=
MOVE_PREREQS += move-User
@

@node Model Class File User
@subsection Model Class File @file{User.js}
@cindex User.js file

@(User.js@)=
@<User_JS Requirements@>
@<User_JS Schema Definition@>
@<User_JS Model Class@>
@

This code must be @code{require}d by some code in order to be executed.
This is best done from within our @file{index.js} file, as a requirement.

@node User Implementation
@subsubsection User.js Implementation
@cindex User.js implementation

@subsubheading Requirements

To create a User schema, we must import the @file{mongoose} package, and
then grab its @file{Schema} method (using ES6 shortcut).

@<User_JS Requirements@>=
const mongoose = require('mongoose');
const { Schema } = mongoose;
@

@subsubheading Schema

Create a new schema that contains the User's Google profile @samp{id};
add a hook here so that we can add new schema attributes in the future. 

@<User_JS Schema Definition@>=
const userSchema = new Schema({
  @<User_JS Schema Hook@>
});
@

@<User_JS Schema Hook@>=
googleId: String,
@

@subsubheading Model Class

Create a model class for a @samp{user} collection and @samp{userSchema};
a model class is created by calling the method with two parameters:

@defun mongoose.model @var{collection} @var{schema}
@end defun
@anchor{Model Class}

@<User_JS Model Class@>=
mongoose.model('users', userSchema);
@

@node Required by Index_JS
@subsubsection Require'd by @file{index.js}

For a note about tricky ordering, @pxref{Tricky Order}.

@<Import Model User@>=
require('./src/models/User');
@

@node Mongoose Model Instances
@section Saving Model Instances
@cindex model instances, saving

Now that we have created a @samp{model class}, we need to create and
save a @samp{model instance} so that a User's @code{id} can be stored
and then later retrieved.  The User's profile is obtained from the
callback function associated with the Passport authentication and
authorization call currently in @file{passport.js} (@pxref{Tokens}).
The callback receives several parameters, one of which is a
@code{profile}.  One of the objects attached to this @code{profile} is
the @code{id}.  The callback function receives the @code{profile}, and
extracts the @code{id} from it.  This token must be @code{save}d in our
database in order to retrieve it in future sessions.

@subheading Accessing Mongoose Model Class

First, however, we need to get access to the Mongoose Model that we
created in @file{models/User.js} (@pxref{Model Class File User}).
Usually, this file would @code{export} some code that would then be
@code{require}d by some other code.  We will not do that here because it
would become confused about what Models we were actually using when run
inside a testing environment (@file{mocha} or @file{jest}).  So,
instead, the @file{passport.js} file will @code{require} the
@file{mongoose} package, and then call its @code{model} method with the
collection name: @code{users}.

@subsubheading Require mongoose package

@<Passport Requirements@>=
const mongoose = require('mongoose');
@

@subsubheading Create a User Object

Our @file{User.js} code loaded a @code{userSchema} associated with a
@code{users} collection into Mongoose.  Now, we can extract that schema
into an object by called the @code{model} method with just the
collection name, @code{users}.  The variable @code{User} becomes our
Model Class.  This Model Class can then be used to create a Model
Instance (a single record) that can be persisted in our database.

@<Passport Requirements@>=
const User = mongoose.model('users');
@

@subsubheading Create a Model Instance from User Class
@cindex new User

A @code{new User} represents the creation of a single record, i.e., a
single User inside the database.  The @code{save} method must be called
to persist this record.  This method returns a promise, which will later
be used to call the @code{done} method.

@<Mongoose New User Save@>=
new User({ googleId: profile.id }).save()
@

The new User and save code will be used in the event a new User logs in;
however, we need to first @code{query} our database to see if the User
is new or not; if not, then there is no need to create a new entry in
the database.  The @code{findOne} method simply queries the database for
an existing user.  @xref{Mongoose Queries}. 
@cindex findOne
@cindex done
@anchor{Done}

@<Google Strategy Callback Function2@>=
(accessToken, refreshToken, profile, done) => {
  @<Mongoose User FindOne@>  
}
@

This callback function is the second argument of the GoogleStrategy
options; the first argument does not change.

@<Google Strategy Options2@>=
@<Google Strategy Object@>,
@<Google Strategy Callback Function2@>
@

Now use the new GoogleStrategy with the new callback:

@<Passport Use GoogleStrategy2@>=
@<Passport Header@>
passport.use(
  new GoogleStrategy(
    @<Google Strategy Options2@>
  )
);
@

@node Mongoose Queries
@section Mongoose Queries
@cindex queries, mongoose
@cindex findOne
@cindex asynchronous operation
@cindex promise

At this point our code will simply add a new entry in our database even
if it represents the same User.  This code must be refactored to first
check to see if the User attempting to log in has already logged in
before.  If so, then skip the create User code.  If not, then create a
new User.

We will use our Model Class to search through all of the records in our
database.  We will use a method @code{findOne} on the @code{User} Class
object.  This method is an @dfn{asynchronous} operation and therefore
returns a @code{promise} and is placed first in the callback.  The
promise will return a User Model Instance (@code{existingUser} that will
be null if there is no User already stored in the database.

@<Mongoose User FindOne@>=
 User.findOne({ googleId: profile.id })
   .then( (existingUser) => {
     if (existingUser) {
       // have a record
       console.log(`found an existing user: ${existingUser}`);
       @<Mongoose Done@>
     } else {
       // create a new record
       console.log(`creating a new user for ${profile.id}`);
       @<Mongoose New User Save@>
       .then(user => done(null, user));
     }
   });
@

@node Passport Callbacks
@section Passport Callbacks
@cindex passport callbacks
@cindex done

The GoogleStragegy code provides us with a @code{done} function as one
of its parameters.  @xref{Done}. When we have finished creating our User
in our database, or have found a User in the database, we call this
@code{done} function to inform Passport that we are @samp{done} with
what we have to do and it can proceed with the authentication flow.
Done takes two parameters, as follows: @anchor{done function}

@defun done @var{error} @var{USER_RECORD}
This function communicates with Passport that the callback has completed
its job and Passport can continue its authentication flow.
@end defun

@<Mongoose Done@>=
done(null, existingUser);
@

@node Encoding Users
@section Encoding Users
@cindex encoding users
@cindex serializeUser

Passport will call a function @code{serializeUser} with the User's
@code{id} that it has obtained from Google.  This will set a
@dfn{cookie} in the User's browser.  When a logged-in User makes another
request to the server, that @samp{cookie} will automatically be sent by
the browser.  Passport will then take that @samp{cookie} and call a
second function called @code{deserializeUser}.  Passport will use that
cookie to return a User Model to the server.

@node Serialize User
@subsection Serialize User Function
@cindex serializeUser
@cindex done

Serialize User is already a function in Passport; we provide it with a
function as its parameter.  Our function takes two arguments:
@code{user} (our User Instance) and @code{done}.  @samp{done} takes two
parameters: an error, and an @samp{id} (MongoDB's id code, not the
Google id).  @xref{done function}

@<Serialize User@>=
passport.serializeUser(
  (user, done) => {
    done(null, user.id);
  }
);
@

@(passport.js@)=
@<Serialize User@>
@

@node Deserialize User
@subsection Deserialize User
@cindex deserialize user
@cindex deserializeUser
@cindex findById

@dfn{Deserialize User} means to take a @samp{user.id} and turn that into
an actual @samp{user model}.  @command{passport.deserializeUser} takes a
callback that we define:

@<Deserialize User@>=
passport.deserializeUser(
  @<Deserialize User Callback@>
);
@

@subsubheading Deserialize User Callback

Our callback will take two parameters: @var{USER_ID} and @var{done}.  We
will use the @var{USER_ID} to obtain a Mongoose Model Instance
@var{user}.  We do that by using the Mongoose method
@code{User.findById()}.

@<Deserialize User Callback@>=
(id, done) => {
  @<Mongoose findById Method@>
}
@

@subsubheading Mongoose findById method

@samp{findById} works be receiving an @code{id} and then searching every
document for a record that contains that @code{id}.  Anytime we access
our database, it is done through an @strong{asynchronous} action and so
returns a @strong{promise} that is @strong{resolved} after a @var{user}
with the given @var{id} is found.  After the @var{user} is found, we
will call @code{done} with that @var{user}.  @code{done} always takes
two parameters: an @code{error} object and the @var{user} that we found.

@<Mongoose findById Method@>=
User.findById(id)
  .then (user => {
    done(null, user);
  });
@

@(passport.js@)=
@<Deserialize User@>
@

@subsubheading Cookies

While we have just defined @code{serializeUser} and
@code{deserializeUser}, we still have to tell @code{Passport} that we
want it to manage our authentication using cookies.  This is only one
way in @code{Passport} can do this job, and so we must instruct it to do
so.  

@node cookie-session
@subsection Enable Cookies with @file{cookie-session}
@cindex cookies, enable
@cindex cookie-session, package
@cindex package cookie-session

Express does not know that we want it to manage authentication of users
by using @samp{cookies}, nor even how to do that, and so it must receive
a helper package, @file{cookie-session}.

@node Import cookie-session
@subsubsection Load and Import Cookie-Session and Passport
@cindex require cookie-session
@cindex cookie-session, require
@cindex import cookie-session

@subsubheading Install cookie-session

The first step is to install @file{cookie-session} as a requirement of
our project:

@<Makefile NPM_INSTALLS@>=
NPM_INSTALLS += cookie-session
@

@subsubheading Require cookie-session

and then import this package into our @file{index.js} file.

@<Import Cookie-Sessions@>=
const cookieSession = require('cookie-session');
@

@subsubheading Require passport

In addition to importing@file{cookie-session}, we also need to import
the @file{passport} package into @file{index.js} as well.

@<Index3JS Requirements@>=
@<Import Cookie-Sessions@>
@<Import Passport@>
@

@node Use cookie-session
@subsubsection App Use Cookie-Sessions
@cindex use cookie-session
@cindex cookie-session, use

We have named our @file{Express} server @code{app}.  @code{app} has a
@code{use} method which will receive the @file{cookie-session} code that
we just imported.  We will discuss the @code{use} method of
@file{Express} in a later section.

@<App Use Hook@>=
 
/*-------------------
 * CookieSession    
 *-------------------*/
app.use(
  @<App Use cookieSession@>
);
@

@subsubheading Use cookieSession

@file{cookie-session} itself takes two parameters: a @code{maxAge} in
milliseconds, and an array of @code{keys} that are used to encrypt the
cookie.

@<App Use cookieSession@>=
cookieSession({
  @<cookieSession maxAge Parameter@>
  @<cookieSession keys Parameter@>
})
@

@subsubheading maxAge of 30 days

Let's set @code{maxAge} to 30 days (in milliseconds):

@<cookieSession maxAge Parameter@>=
maxAge: 30 * 24 * 60 * 60 * 1000,
@

@subsubheading cookieKey

Nex, we add an attribute to our @file{keys.js} object to help Express do
the encryption: @samp{cookieKey}, which is a random string of
characters.  Whenever we send out this cookie, it will always be
encrypted.  We place a random string of characters into our
@file{keys.js} @file{config} file so that it is not saved as part of our
public code, but kept secret, and the cookie-session code will read this
random string as part of the exported @file{keys} object.

@<CookieKey@>=
  cookieKey: 'dkdfnvasiiennvkldaldkeislsldf',
@

Place this @code{cookieKey} into @file{keys.js}:

@<Keys_JS Internals@>=
@<CookieKey@>
@

The @code{cookie-session} parameter reads this @code{cookieKey} from the
@file{keys.js} object.  @file{cookie-session} takes an array of random
strings, and randomly picks one each time as an extra measure of
security. 

@<cookieSession keys Parameter@>=
keys: [keys.cookieKey]
@

@node Passport Use Cookies
@subsubsection Passport Use Cookies
@cindex use cookies

The last step is tell @file{Passport} that it should make use of
@samp{cookies} to handle authentication.  First, @command{initialize}
@file{Passport}, and then tell @file{Passport} to use
@file{cookie-session}.

These last two commands essentially complete authentication for our
app.  

@<App Use Hook@>=
app.use(passport.initialize());
app.use(passport.session());
@

@node Testing Authentication
@section Testing Authentication
@cindex authentication, testing

In the last section, we finished wiring up the @samp{authentication
flow} by enabling cookies (telling @file{app} to @code{use} the
@file{cookie-session} library) and then telling @file{Passport} to use
cookies to @samp{manage} our authentication (@code{use
}@code{initialize} and @code{session}).  We are now able to
@samp{authenticate}, but what does this mean for our application?

@anchor{Middleware Diagram}
@subheading Authentication Flow Diagram

@table @b
@item Request Comes In

@item Cookie-Session
Extracts cookie data

@item Passport
Pulls User_Id out of cookie data

@item Deserialize User
Function to turn User_Id into a User

@item Request (@code{req})
User Model Instance added to Request Object as @code{req.user}

@item Route Handler
Request is sent to the Route Handler

@end table

To test this process, we will add a new route handler whose sole job is
to inspect the @code{req.user} property.  If we can get ahold of this
property, then our authentication must be working properly.

@node Route Handler for req user
@subsection Route Handler for @code{req.user}
@cindex route handler, req.user
@cindex req.user route handler

Add a third route handler to the @file{authRoutes.js} file, underneath
the two handlers dealing with Google's authentication.  This handler
will simply return the @code{req.user} property.

@<Current User Route Handler@>=
app.get('/api/current_user', (req, res) => {
  res.send(req.user);
})
@

@<AuthRoutes Route Handler Hook@>=
@<Current User Route Handler@>
@

@node Logging Out Users
@section Logging Out Users
@cindex logging out, users
@cindex users, logging out

One final bit of code is required to allow a User to log out of the
application.  Add a route handler inside @file{authRoutes.js} called
@code{/api/logout} that logs out the User.  Passport adds a method to
the @code{req} object called @samp{logout}.  When this method is
executed, Passport @samp{kills} the @samp{user_id} that is inside the
cookie.  To send a message to the User that that person is actually
logged out, send a message that includes the @samp{user}, which should
be undefined at that point (nothing will be logged to the browser).
Also, hitting @kbd{/api/current_user} should produce a totally blank
browser screen also.

@<AuthRoutes Route Handler Hook@>=
app.get('/api/logout', (req, res) => {
  req.logout();
  res.send(req.user);
});
@

@node Deeper Dive
@section A Deeper Dive
@cindex deeper

This is an optional discussion about some of the topics that were glazed
over in the discussions above.

@node App Use
@subsection App Use
@cindex app.use
@cindex middleware

There are three separate @code{app.use} calls in the code above, each
call receiving some object.
@xref{Use cookie-session}  @xref{Passport Use Cookies}

These calls are wiring up @dfn{middleware} inside of our application.
Middlewares are small functions that can be used to modify incoming
requests to our app before they are sent off to route handlers.  Refer
to the diagram at @ref{Middleware Diagram}.  Each of the middle objects
is a middleware that is receiving the @samp{request} and making some
minor adjustment to it.

Middlewares are all about doing some preprocessing of the incoming
request before sending it off to the route handlers.  These middlewares
can also be wired up so that they handle just the type of requests that
you want to handle, rather than every request.

@node How Express Works
@subsubsection How Express Works
@cindex express, how it works

@table @b{}
@item Request from Browser
Somebody makes a @code{request} from a browser

@item Express creates App
@code{express()} @result{} @code{app} @*
@code{request} goes to our @samp{app}, which has been created by @file{express}

@item middleware #1
Middleware maniputes @code{request}

@item middleware #2
Middleware manipulates @code{request}

@item Route Handlers
A route handler processes @code{request}

@itemize
@item get
@item post
@item delete
@item put
@end itemize

@item response
App sends completed @code{response} to whomever made the @code{request}

@end table

@node Cookie-Session Middleware
@subsection Cookie-Session Middleware
@cindex cookie-session, middleware
@cindex middleware cookie-session
@cindex request session

What is @code{cookie-session} doing?

In the route handler @code{/api/current_user}, change the response to
@kbd{res.send(req.session)} to obtain the @samp{request session} object.
The @code{cookie-session} middleware extracts the @samp{user_id} out of
the cookie it receives from the browser, and assigns it to the
@code{req.session} object.  The @code{req.session} object looks like
@code{passport: @{user: "595f @dots{}"@}}.  @code{req.session} contains the
data that Passport is attempting to store inside the cookie.  When
Passport receives the @code{request} from @code{cookie-session}, it is
looking at the data inside the @code{req.session} object.  Passport then
pulls out the data from @code{req.session} and sends it to
@code{deserializeUser}.

@subsubheading Express Session
@cindex express session, middleware

Express documenation relating to cookies will recommend two different
libraries: @code{cookie-session} and @code{express-session}.  Both
libraries essentially accomplish the same thing, but go about it in
totally different ways.  @code{Express session} works by storing a
@samp{reference} to a session inside the cookie, i.e., a
@code{session_id} rather than a @code{user_id}.  The data is stored in a
database external to the cookie.  The advantage of this method is that
you can store a lot more data than you can store inside a cookie.  The
disadvantage is that it is more complicated and requires more
libraries.  

@node Environments
@chapter Dev vs Prod Environments
@cindex environemnts, dev vs prod
@cindex dev environment
@cindex prod environment

@node Client
@chapter Moving to the Client Side
@cindex client side

@node Developing Client
@chapter Developing the Client Side
@cindex client, developing

@node Payments
@chapter Handling Payments
@cindex payments, handling

@node Production Routing
@chapter Back-End to Front-End Routing in Production
@cindex routing in production
@cindex production routing
@cindex back-end routing
@cindex front-end routing

@node Mongoose
@chapter Mongoose for Survey Creation
@cindex mongoose
@cindex Mongoose

@node Back to Client
@chapter Back to the Client
@cindex client, back to

@node Webhook Data
@chapter Handling Webhook Data
@cindex webhook data

@node Home Stretch
@chapter The Home Stretch
@cindex home stretch

@c ====================
@c APPENDICES
@c ====================

@node Appendix One
@appendix Appendix One

@node Meta Appendix
@appendix Meta (Makefile) Appendix

@node Makefile Definitions
@appendixsec Makefile Initial Definitions

@(Makefile@)=
@<Makefile Constants@>
@<Makefile Default Targets@>
@<Makefile Tangle@>
@<Makefile Weave@>
@<Makefile Info@>
@<Makefile Clean Targets@>
@<Makefile Directory Creation@>
@<Makefile Create Files Targets@>
@<Makefile Move Targets@>
@<Makefile Link Target@>
@<Makefile NPM Targets@>
@<Makefile Run Hook@>
@<Makefile Open Browser@>
@<Makefile Server Stop@>
@<Makefile Git Targets@>
@<Makefile Echo Variables@>
@

@node Makefile Constants
@appendixsubsec Makefile Constant Definitions

@<Makefile Constants@>=
 
####################
# CONSTANT DEF'S
####################
@<Makefile Directory Definitions@>
@<Makefile Filename Definitions@>
@<Makefile Move Prereqs@>
@<Makefile NPM@>
@

@node Directory Definitions
@appendixsubsubsec Makefile Directory Definitions

@<Makefile Directory Definitions@>=
 
####################
# DIRECTORY DEF'S  #
####################
PREFIX := .
@<Makefile Root Definition@>
SOURCE_DIR := ${PREFIX}/${ROOT}/src
PUBLIC_DIR := ${PREFIX}/${ROOT}/public
HTML_DIR := ${PREFIX}/${ROOT}/html
@<Makefile Directory Definitions Hook@>

@

@node Filename Definitions
@appendixsubsubsec Makefile Filename Definitions

@<Makefile Filename Definitions@>=
 
####################
# FILENAME DEF'S   #
####################
@<Makefile Base Filename Definition@>
TWJR_FILENAME := ${FILENAME}.twjr
TEXI_FILENAME := ${FILENAME}.texi
INFO_FILENAME := ${FILENAME}.info
@<Makefile Filename Definitions Hook@>

@

@node Move Prereqs
@appendixsubsubsec Makefile Move Prereqs

@<Makefile Move Prereqs@>=
MOVE_PREREQS ?= NOT_DEFINED

@

@node Makefile Default Targets
@appendixsubsec Makefile Default Targets

@<Makefile Default Targets@>=
 
.Phony : all
all : install-files server-browser

.Phony : install-files
install-files : meta-move-link npm git-init

.Phony : server-browser
server-browser : start-server open-browser

.Phony : meta-move-link
meta-move-link : make-meta move-and-link

.Phony : make-meta
make-meta : tangle weave

.Phony : move-and-link
move-and-link : move link-indexjs

@

@node Makefile Tangle
@appendixsubsubsec Makefile Tangle

@<Makefile Tangle@>=
.Phony : tangle
tangle :
	jrtangle ${TWJR_FILENAME}

@

@node Makefile Weave
@appendixsubsubsec Meta Weave

@<Makefile Weave@>=
.Phony : weave
weave : ${TEXI_FILENAME}

${TEXI_FILENAME} : ${TWJR_FILENAME}
	jrweave ${TWJR_FILENAME} > ${TEXI_FILENAME}

@

@node Makefile Info
@appendixsubsubsec Makefile Info

@<Makefile Info@>=
.Phony : info
info : ${INFO_FILENAME}

${INFO_FILENAME} : ${TEXI_FILENAME}
	makeinfo ${TEXI_FILENAME}

@

@node Makefile Clean Targets
@appendixsubsec Makefile Clean Targets

@<Makefile Clean Targets@>=
@<Makefile Clean@>
@<Makefile Very Clean@>
@<Makefile Dist Clean@>
@

@node Makefile Clean
@appendixsubsubsec Makefile Clean Definition

@<Makefile Clean@>=
.Phony : clean
clean : stop-server
	-rm -f *.{texi,aux,cp,log,toc,js} *~
@<Makefile Clean Hook@>
@

@<Makefile Clean Hook@>=
@

@node Makefile Very Clean
@appendixsubsubsec Makefile Very Clean

@<Makefile Very Clean@>=
.Phony : very-clean
very-clean : clean
	-rm -rf *.{info,js,html} ${HTML_DIR}
	-find -d ${ROOT} \
		-not \( \
		  -path \*/node_modules\* -or \
		  -path \*/.git\* -or \
		  -path ${ROOT} -or \
		  -name package\* \
		\) -exec rm -r {} \;

@

@node Makefile Dist Clean
@appendixsubsubsec Makefile Dist Clean

@<Makefile Dist Clean@>=
@<Makefile Dist Clean Default@>
@<Makefile Dist Clean Hook@>
@

@node Makefile Dist Clean Default
@appendixsubsubsec Makefile Dist Clean Default

@<Makefile Dist Clean Default@>=
.Phony : dist-clean
dist-clean : very-clean
	-rm -rf ${ROOT}
	-rm -rf auto
@

@<Makefile Dist Clean Hook@>=
@

@node Makefile Directory Creation
@appendixsubsec Makefile Directory Creation Targets

@<Makefile Directory Creation@>=
.Phony : ${ROOT}
${ROOT} :
	mkdir -p ${ROOT}

.Phony : ${SOURCE_DIR}
${SOURCE_DIR} :
	mkdir -p ${SOURCE_DIR}

.Phony : ${PUBLIC_DIR}
${PUBLIC_DIR} :
	mkdir -p ${PUBLIC_DIR}

.Phony : ${HTML_DIR}
${HTML_DIR} :
	mkdir -p ${HTML_DIR}

@<Makefile Directory Creation Hook@>

@
@node Directories to gitignore
@appendixsubsubsec Directories to gitignore
@cindex gitignore directories

@(gitignore@)=
${ROOT}
${SOURCE_DIR}
${PUBLIC_DIR}
${HTML_DIR}
@

@node Makefile Create Files Targets
@appendixsubsec Makefile Create Files Targets

Use this target to add new file definitions

@<Makefile Create Files Targets@>=
@

@node Makefile Move Targets
@appendixsubsec Makefile Move Targets

@<Makefile Move Targets@>=
.Phony : move
move : ${MOVE_PREREQS}

@<Makefile Move Hook@>
@

@node Makefile Move Hook
@appendixsubsubsec Makefile Move Hook

Use this hook for moving files to a different directory
than Source; it will execute just prior to the next
code block moving all .js files to Source.

@<Makefile Move Hook@>=
@

@node Makefile Link Target
@appendixsubsec Makefile Link Target

@<Makefile Link Target@>=
.Phony : link-indexjs
link-indexjs :
@<Makefile Link Target Hook@>
@

@node Makefile NPM Targets
@appendixsubsec Makefile NPM Targets

@<Makefile NPM Targets@>=
 
####################
# NPM TARGETS      #
####################
.Phony : npm
npm : ${NPM}

@<Makefile NPM Hooks@>
@

@node Makefile Run Hook
@appendixsubsubsec Makefile Run Hook

@<Makefile Run Hook@>=
@

@node Makefile Open Browser
@appendixsubsubsec Makefile Open Browswer

@<Makefile Open Browser@>=
.Phony : open-browser
open-browser :
	open -a Safari "http://localhost:5000"

@

@node Makefile Stop Server
@appendixsubsec Makefile Stop Server

@<Makefile Server Stop@>=
.Phony : stop-server
stop-server :
	PS=$$(ps -o pid -o comm | grep node | sed -e 's/[^[:digit:]]//g'); \
	[ $${#PS} -ne 0 ] && \
	{ kill $${PS}; echo server process $${PS} stopped; } || \
	echo no node process to kill
#	PS=$$(ps | grep 'node index.js$$' | cut -d ' ' -f 1); [ $${#PS} -ne 0 ] && kill $${PS} || echo no index.js process to kill

@

@<Makefile Git Targets@>=
@

@node Make Echo Variables
@appendixsec Make Echo Variables

@<Makefile Echo Variables@>=
echo-all : echo-index echo-index-all echo-move-prereqs echo-npm-installs
echo-index :
	echo INDEX.JS: ${INDEX.JS}
echo-index-all :
	echo INDEX.JS_ALL: ${INDEX.JS_ALL}
echo-move-prereqs :
	echo MOVE_PREREQS: ${MOVE_PREREQS}
echo-npm-installs :
	echo NPM_INSTALLS: ${NPM_INSTALLS}
@

@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@node File Definitions
@appendixsec Source File Definitions

@print_file_defs

@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs

@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs

@c ====================
@c BIBLIOGRAPHY; INDEX; END
@c ====================

@node Bibliography
@unnumbered Bibliography

@node Concept Index
@unnumbered Index

@node Index
@unnumbered Index

@printindex cp

@bye

@c ====================
@c TODOs
@c ====================

1. Create a script to fill in named variables
1.1 twjr
1.1.1 init [--dir <directory>]
1.1.2 config
1.1.3 weave [--info --pdf --html --xml --docbook]
1.1.4 tangle [--file <filename>
